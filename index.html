<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ¶ æ™ºèƒ½å³å…´å’Œå£°ç»ƒä¹ å™¨ v4.0</title>
<script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
<style>
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; text-align: center; padding: 20px; background: #f4f7f6; color: #2d3748; }
  .container { max-width: 650px; margin: 0 auto; background: white; padding: 40px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.05); }
  h2 { color: #4c51bf; margin-bottom: 10px; }
  p { color: #718096; font-size: 0.9em; margin-bottom: 30px; }
  
  .controls { display: flex; flex-direction: column; gap: 20px; align-items: center; }
  select, button { width: 100%; max-width: 300px; padding: 14px; font-size: 16px; border-radius: 12px; border: 1px solid #e2e8f0; cursor: pointer; transition: all 0.3s ease; }
  
  button#record { background: #4c51bf; color: white; border: none; font-weight: 600; }
  button#record:hover { background: #434190; transform: translateY(-2px); }
  button#stop { background: #f56565; color: white; border: none; font-weight: 600; }
  button#stop:disabled { background: #edf2f7; color: #a0aec0; transform: none; }

  .checkbox-wrapper { display: flex; align-items: center; gap: 12px; font-size: 15px; user-select: none; }
  input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }

  audio { margin-top: 30px; width: 100%; border-radius: 30px; }
  .status { margin-top: 20px; font-size: 14px; color: #5a67d8; font-weight: bold; min-height: 1.5em; }
  .hint { font-size: 12px; color: #a0aec0; margin-top: 10px; }
</style>
</head>
<body>

<div class="container">
  <h2>ğŸ¶ å³å…´å’Œå£°ç»ƒä¹ å™¨</h2>
  <p>è®© AI æ­Œæ‰‹ä¸ºä½ å³å…´ä¼´å”±ï¼Œæ‹’ç»æœºæ¢°æ„Ÿ</p>

  <div class="controls">
    <select id="mode">
      <option value="4">åŸºå‡†ï¼šå¤§ä¸‰åº¦ (å³å…´æ¨¡å¼)</option>
      <option value="3">åŸºå‡†ï¼šå°ä¸‰åº¦ (å³å…´æ¨¡å¼)</option>
      <option value="7">åŸºå‡†ï¼šçº¯äº”åº¦ (å³å…´æ¨¡å¼)</option>
      <option value="12">åŸºå‡†ï¼šé«˜å…«åº¦ (å³å…´æ¨¡å¼)</option>
      <option value="0">å®Œå…¨éšæœºå³å…´</option>
    </select>

    <div class="checkbox-wrapper">
      <input type="checkbox" id="soloToggle">
      <label for="soloToggle">åªå¬å’Œå£° (æ„Ÿå—éšæœºæ—‹å¾‹çº¿)</label>
    </div>

    <button id="record">ğŸ¤ å¼€å§‹å½•åˆ¶ä½ çš„æ—‹å¾‹</button>
    <button id="stop" disabled>â¹ åœæ­¢å¹¶æ¿€å‘ä¼´å”±</button>
  </div>

  <div class="status" id="statusText">ç­‰å¾…éº¦å…‹é£æˆæƒ...</div>
  <audio id="player" controls></audio>
  <div class="hint">å»ºè®®ä½©æˆ´è€³æœºä»¥æ„Ÿå—ç«‹ä½“å£°äº¤äº’æ•ˆæœ</div>
</div>

<script>
let recorder, chunks = [];
const recordBtn = document.getElementById("record");
const stopBtn = document.getElementById("stop");
const player = document.getElementById("player");
const mode = document.getElementById("mode");
const soloToggle = document.getElementById("soloToggle");
const statusText = document.getElementById("statusText");

// ç¯å¢ƒæ£€æŸ¥
window.onload = () => {
  if (typeof Tone === 'undefined') {
    statusText.innerText = "âŒ æ ¸å¿ƒåº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ";
  } else {
    statusText.innerText = "âœ… å‡†å¤‡å°±ç»ªï¼Œå¯ä»¥å¼€å§‹è¡¨æ¼”";
  }
};

recordBtn.onclick = async () => {
  try {
    if (Tone.context.state !== 'running') await Tone.start();

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    recorder = new MediaRecorder(stream);
    chunks = [];
    
    recorder.ondataavailable = e => chunks.push(e.data);
    recorder.onstop = processAudio;

    recorder.start();
    recordBtn.disabled = true;
    stopBtn.disabled = false;
    statusText.innerText = "ğŸ”´ æ­£åœ¨è†å¬ä½ çš„æ—‹å¾‹...";
    player.src = "";
  } catch (err) {
    statusText.innerText = "âŒ æƒé™é”™è¯¯ï¼š" + err.message;
  }
};

stopBtn.onclick = () => {
  if (recorder && recorder.state === "recording") {
    recorder.stop();
    recorder.stream.getTracks().forEach(track => track.stop());
  }
  recordBtn.disabled = false;
  stopBtn.disabled = true;
};

async function processAudio() {
  statusText.innerText = "â³ ä¼´å”±æ­Œæ‰‹æ­£åœ¨æ„æ€å³å…´æ®µè½...";
  
  try {
    const blob = new Blob(chunks, { type: 'audio/webm' });
    const arrayBuffer = await blob.arrayBuffer();
    const context = new AudioContext();
    const originalBuffer = await context.decodeAudioData(arrayBuffer);

    const isSolo = soloToggle.checked;
    const renderDuration = originalBuffer.duration + 1.0;
    
    // ç¦»çº¿æ¸²æŸ“å³å…´éŸ³é¢‘
    const renderedBuffer = await Tone.Offline(async () => {
      const sourcePlayer = new Tone.Player(originalBuffer);
      
      // 1. å˜è°ƒå™¨ - å¢åŠ åé¦ˆè®©å£°éŸ³æ›´ç©ºçµ
      const pitchShifter = new Tone.PitchShift({
        windowSize: 0.12,
        feedback: 0.05
      });

      // 2. å¢åŠ â€œåŠ¨æ€ä¸ç¡®å®šæ€§â€ï¼šé¢¤éŸ³å’Œè½»å¾®åˆå”±
      const vibrato = new Tone.Vibrato(4, 0.1).start(); 
      const chorus = new Tone.Chorus(2, 1.5, 0.2).start();

      // 3. ç«‹ä½“å£°å®šä½ï¼šå·¦å³æ‹‰å¼€å®½åº¦
      const originalPan = new Tone.Panner(-0.35).toDestination(); 
      const harmonyPan = new Tone.Panner(0.45).toDestination();

      // 4. å“ˆæ–¯æ•ˆåº”ï¼šè®©ä¸¤ä¸ªå£°éŸ³åœ¨æ—¶é—´ä¸Šé”™å¼€ï¼Œäº§ç”Ÿç‹¬ç«‹æ„Ÿ
      const humanDelay = new Tone.Delay(0.03); 

      // --- æ ¸å¿ƒï¼šå³å…´é€»è¾‘ç”Ÿæˆå™¨ ---
      const baseInterval = Number(mode.value);
      const duration = originalBuffer.duration;
      let time = 0;

      while (time < duration) {
        // éšæœºæ± ï¼šåŸºå‡†éŸ³ã€é‚»éŸ³ã€å’Œè°éŸ³ï¼ˆäº”åº¦ã€å…«åº¦ï¼‰ã€æˆ–è€…æ˜¯çŸ­æš‚çš„æ²‰é»˜ï¼ˆåŸéŸ³ï¼‰
        const intervalPool = [baseInterval, baseInterval + 2, baseInterval - 2, baseInterval + 5, baseInterval + 7, baseInterval === 0 ? 4 : 0];
        const randomPitch = intervalPool[Math.floor(Math.random() * intervalPool.length)];
        
        // ä½¿ç”¨è°ƒåº¦çš„æ¯«ç§’çº§ç²¾åº¦æ”¹å˜éŸ³é«˜
        Tone.Transport.schedule(() => {
          pitchShifter.pitch = randomPitch;
        }, time);

        // æ”¹å˜éŸ³é«˜çš„é¢‘ç‡éšæœºåŒ– (æ¨¡æ‹Ÿäººçš„ä¹å¥æ„Ÿ)
        time += (Math.random() * 0.7 + 0.3);
      }

      // è·¯ç”±è¿æ¥
      if (isSolo) {
        sourcePlayer.chain(pitchShifter, vibrato, chorus, harmonyPan);
      } else {
        // åŸå£°è·¯å¾„
        sourcePlayer.connect(originalPan);
        // å³å…´ä¼´å”±è·¯å¾„
        sourcePlayer.chain(pitchShifter, vibrato, humanDelay, chorus, harmonyPan);
        sourcePlayer.volume.value = -1; // æ··éŸ³å¹³è¡¡
      }

      sourcePlayer.start(0);
      Tone.Transport.start();
    }, renderDuration);

    const wavBlob = bufferToWave(renderedBuffer);
    player.src = URL.createObjectURL(wavBlob);
    statusText.innerText = "âœ¨ å³å…´ä¼´å”±å·²ç”Ÿæˆï¼ç‚¹å‡»ä¸‹æ–¹é¢„è§ˆ";

  } catch (e) {
    statusText.innerText = "âŒ ç”Ÿæˆå¤±è´¥ï¼š" + e.message;
    console.error(e);
  }
}

// è¾…åŠ©å‡½æ•°ï¼šBufferè½¬WAV
function bufferToWave(abuffer) {
  const numOfChan = abuffer.numberOfChannels;
  const length = abuffer.length * numOfChan * 2 + 44;
  const buffer = new ArrayBuffer(length);
  const view = new DataView(buffer);
  const channels = [];
  let i, sample, offset = 0, pos = 0;
  const setUint16 = (data) => { view.setUint16(pos, data, true); pos += 2; }
  const setUint32 = (data) => { view.setUint32(pos, data, true); pos += 4; }
  setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157);
  setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
  setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4);
  for (i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));
  while (pos < length) {
    for (i = 0; i < numOfChan; i++) {
      sample = Math.max(-1, Math.min(1, channels[i][offset]));
      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
      view.setInt16(pos, sample, true); pos += 2;
    }
    offset++;
  }
  return new Blob([buffer], { type: "audio/wav" });
}
</script>

</body>
</html>
