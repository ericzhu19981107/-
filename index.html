<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ¶ æ™ºèƒ½å’Œå£°ç»ƒä¹ å™¨ v3.0 (åŒæ­¥ç‰ˆ)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<style>
  body { font-family: 'Segoe UI', sans-serif; text-align: center; padding: 20px; background: #f0f2f5; color: #333; }
  .container { max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
  h2 { color: #5a67d8; margin-bottom: 20px; }
  
  .controls { margin: 20px 0; display: flex; flex-direction: column; gap: 15px; align-items: center; }
  select, button { padding: 12px 24px; font-size: 16px; border-radius: 8px; border: 1px solid #cbd5e0; cursor: pointer; transition: 0.2s; }
  
  button { background: #5a67d8; color: white; border: none; font-weight: bold; width: 80%; }
  button:hover { background: #4c51bf; }
  button:disabled { background: #cbd5e0; cursor: not-allowed; }
  button#stop { background: #e53e3e; }
  button#stop:hover { background: #c53030; }

  .checkbox-wrapper { display: flex; align-items: center; gap: 10px; font-size: 16px; margin-top: 10px; }
  input[type="checkbox"] { transform: scale(1.5); cursor: pointer; }

  audio { margin-top: 25px; width: 100%; outline: none; }
  .status { margin-top: 15px; font-size: 14px; color: #718096; min-height: 20px; }
  
  /* åŠ è½½åŠ¨ç”» */
  .spinner { display: inline-block; width: 12px; height: 12px; border: 2px solid #ccc; border-top-color: #5a67d8; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 5px; display: none; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .processing .spinner { display: inline-block; }
</style>
</head>
<body>

<div class="container">
  <h2>ğŸ¶ å’Œå£°ç»ƒä¹ å™¨ <small style="font-size:0.6em; color:#999">åŒæ­¥ç‰ˆ</small></h2>

  <div class="controls">
    <select id="mode">
      <option value="4">å¤§ä¸‰åº¦ (Major 3rd)</option>
      <option value="3">å°ä¸‰åº¦ (Minor 3rd)</option>
      <option value="-4">ä½å¤§ä¸‰åº¦ (Lower Maj 3rd)</option>
      <option value="-3">ä½å°ä¸‰åº¦ (Lower Min 3rd)</option>
      <option value="5">çº¯äº”åº¦ (Perfect 5th)</option>
      <option value="7">çº¯å…«åº¦ (Octave)</option>
      <option value="smart">ğŸ² éšæœºå¤§å°ä¸‰åº¦</option>
    </select>

    <div class="checkbox-wrapper">
      <input type="checkbox" id="soloToggle">
      <label for="soloToggle">åªå¬å’Œå£° (Solo Harmony)</label>
    </div>

    <button id="record">ğŸ¤ å¼€å§‹å½•éŸ³</button>
    <button id="stop" disabled>â¹ åœæ­¢å¹¶ç”Ÿæˆ</button>
  </div>

  <div class="status" id="statusText">è¯·å…è®¸éº¦å…‹é£æƒé™åå¼€å§‹</div>
  <audio id="player" controls></audio>
</div>

<script>
let recorder, chunks = [];
const recordBtn = document.getElementById("record");
const stopBtn = document.getElementById("stop");
const player = document.getElementById("player");
const mode = document.getElementById("mode");
const soloToggle = document.getElementById("soloToggle");
const statusText = document.getElementById("statusText");

// åˆå§‹åŒ– Tone.js Context (éœ€è¦ç”¨æˆ·ç‚¹å‡»)
let isToneStarted = false;

recordBtn.onclick = async () => {
  if (!isToneStarted) {
    await Tone.start();
    isToneStarted = true;
  }

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    recorder = new MediaRecorder(stream);
    chunks = [];
    
    recorder.ondataavailable = e => chunks.push(e.data);
    
    recorder.onstop = async () => {
      // 1. è·å–å½•éŸ³åŸå§‹æ•°æ®
      statusText.innerHTML = '<span class="spinner"></span>æ­£åœ¨å¤„ç†éŸ³é¢‘åŒæ­¥...';
      statusText.classList.add('processing');
      
      const blob = new Blob(chunks, { type: 'audio/webm' });
      const arrayBuffer = await blob.arrayBuffer();
      
      // 2. å°† WebM è§£ç ä¸º AudioBuffer
      const context = new AudioContext(); // ä¸´æ—¶ Context ç”¨äºè§£ç 
      const originalBuffer = await context.decodeAudioData(arrayBuffer);

      // 3. è®¡ç®—éœ€è¦çš„éŸ³ç¨‹
      let semitones = mode.value === "smart"
        ? (Math.random() > 0.5 ? 3 : 4)
        : Number(mode.value);
      
      const isSolo = soloToggle.checked;

      // 4. ä½¿ç”¨ Tone.Offline è¿›è¡Œç¦»çº¿æ¸²æŸ“ (æ ¸å¿ƒåŒæ­¥é€»è¾‘)
      // duration ç¨å¾®åŠ ä¸€ç‚¹é˜²æ­¢å°¾éŸ³æˆªæ–­
      const renderDuration = originalBuffer.duration + 0.5;
      
      const renderedBuffer = await Tone.Offline(async ({ transport }) => {
        
        // åˆ›å»ºæ’­æ”¾å™¨æº (Source)
        const sourcePlayer = new Tone.Player(originalBuffer);
        
        // åˆ›å»ºå˜è°ƒå™¨ (PitchShift) - è¿™æ˜¯"åŒæ­¥"çš„å…³é”®
        // windowSize 0.1 é€‚åˆäººå£°ï¼ŒdelayTime 0 å‡å°‘å»¶è¿Ÿ
        const pitchShifter = new Tone.PitchShift({
          pitch: semitones,
          windowSize: 0.1,
          delayTime: 0,
          feedback: 0
        });

        // è·¯ç”±é€»è¾‘
        if (isSolo) {
          // åªè¿æ¥ï¼šåŸå£° -> å˜è°ƒ -> è¾“å‡º
          sourcePlayer.connect(pitchShifter);
          pitchShifter.toDestination();
        } else {
          // æ··åˆè¿æ¥ï¼š
          // 1. åŸå£° -> è¾“å‡º (å¹²å£°)
          // 2. åŸå£° -> å˜è°ƒ -> è¾“å‡º (æ¹¿å£°)
          sourcePlayer.toDestination(); // åŸå£°
          sourcePlayer.connect(pitchShifter); // å‘é€ç»™å˜è°ƒå™¨
          pitchShifter.toDestination(); // å˜è°ƒåè¾“å‡º
          
          // å¹³è¡¡éŸ³é‡ï¼šä¸¤äººä¸€èµ·å”±ï¼ŒéŸ³é‡å‡å°ä¸€ç‚¹é˜²æ­¢çˆ†éŸ³
          sourcePlayer.volume.value = -2; 
        }

        // å¼€å§‹æ¸²æŸ“æµç¨‹
        sourcePlayer.start(0);
        
      }, renderDuration);

      // 5. å°†æ¸²æŸ“ç»“æœè½¬ä¸º WAV å¹¶æ’­æ”¾
      const wavBlob = bufferToWave(renderedBuffer);
      player.src = URL.createObjectURL(wavBlob);
      
      statusText.classList.remove('processing');
      statusText.innerText = `âœ… ç”Ÿæˆå®Œæ¯•ï¼å½“å‰ï¼š${semitones} åŠéŸ³ ${isSolo ? "(ä»…å’Œå£°)" : "(æ··åˆ)"}`;
    };

    recorder.start();
    recordBtn.disabled = true;
    stopBtn.disabled = false;
    statusText.innerText = "ğŸ”´ æ­£åœ¨å½•éŸ³...";
    player.src = "";
    
  } catch (err) {
    alert("æ— æ³•è®¿é—®éº¦å…‹é£æˆ–å¤„ç†éŸ³é¢‘ï¼š" + err);
    console.error(err);
    statusText.innerText = "âŒ å‘ç”Ÿé”™è¯¯";
    recordBtn.disabled = false;
  }
};

stopBtn.onclick = () => {
  recorder.stop();
  recordBtn.disabled = false;
  stopBtn.disabled = true;
};

// è¾…åŠ©å‡½æ•°ï¼šAudioBuffer è½¬ WAV Blob
function bufferToWave(abuffer) {
  const numOfChan = abuffer.numberOfChannels;
  const length = abuffer.length * numOfChan * 2 + 44;
  const buffer = new ArrayBuffer(length);
  const view = new DataView(buffer);
  const channels = [];
  let i;
  let sample;
  let offset = 0;
  let pos = 0;

  // å†™å…¥ WAV å¤´ä¿¡æ¯
  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8); // file length - 8
  setUint32(0x45564157); // "WAVE"

  setUint32(0x20746d66); // "fmt " chunk
  setUint32(16); // length = 16
  setUint16(1); // PCM (uncompressed)
  setUint16(numOfChan);
  setUint32(abuffer.sampleRate);
  setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
  setUint16(numOfChan * 2); // block-align
  setUint16(16); // 16-bit (hardcoded in this demuxer)

  setUint32(0x61746164); // "data" - chunk
  setUint32(length - pos - 4); // chunk length

  // å†™å…¥äº¤é”™æ•°æ®
  for (i = 0; i < abuffer.numberOfChannels; i++)
    channels.push(abuffer.getChannelData(i));

  while (pos < length) {
    for (i = 0; i < numOfChan; i++) {
      // clamp value
      sample = Math.max(-1, Math.min(1, channels[i][offset]));
