<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äººå£°å’Œå£°ç”Ÿæˆå™¨ - AI Harmony</title>
    <style>
        /* --- è¿™ä¸€éƒ¨åˆ†ä¿ç•™ä½ åŸæœ‰çš„ CSSï¼Œæ­¤å¤„ä»…è¡¥å……ç¼ºå¤±æˆ–éœ€è¦è°ƒæ•´çš„éƒ¨åˆ† --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; padding-bottom: 50px; }
        header { text-align: center; padding: 30px 0; }
        header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        header p { color: #888; font-size: 1.1rem; }
        .main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-top: 20px; }
        @media (max-width: 900px) { .main-grid { grid-template-columns: 1fr; } }
        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .card:hover { transform: translateY(-5px); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3); }
        .card h2 { font-size: 1.3rem; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .card h2 .icon { width: 35px; height: 35px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; }
        
        /* å½•éŸ³æŒ‰é’®æ ·å¼ */
.record-controls { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        .record-btn {
            width: 100px; height: 100px; border-radius: 50%; border: none; cursor: pointer; font-size: 2rem;
            transition: all 0.3s; position: relative; overflow: hidden;
        }
        .record-btn.idle { background: linear-gradient(145deg, #ff6b6b, #ee5a5a); box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4); }
        .record-btn.recording { background: linear-gradient(145deg, #ff4757, #ff3838); animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.7); } 50% { box-shadow: 0 0 0 20px rgba(255, 71, 87, 0); } }
        
        .waveform-container { margin-top: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 15px; padding: 15px; height: 100px; display: flex; align-items: center;}
        .waveform-canvas { width: 100%; height: 100%; display: block; }
        
        .pitch-display { display: flex; justify-content: space-around; margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px;}
.pitch-item { text-align: center; }
        .pitch-item .value { font-size: 1.2rem; font-weight: bold; color: #00d4ff; }
        
        .file-upload { margin-top: 20px; padding: 20px; border: 2px dashed rgba(255,255,255,0.2); border-radius: 15px; text-align: center; cursor: pointer; }
        .file-upload input { display: none; }

        /* å’Œå£°æ§åˆ¶ */
        .harmony-voices { display: flex; flex-direction: column; gap: 15px; }
        .voice-control { background: rgba(0,0,0,0.2); border-radius: 12px; padding: 15px; border: 1px solid transparent; }
        .voice-control.active { border-color: rgba(123, 44, 191, 0.5); background: rgba(123, 44, 191, 0.1); }
        .voice-header { display: flex; justify-content: space-between; margin-bottom: 10px; }
        .voice-settings { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        select, input[type="range"] { width: 100%; background: rgba(255,255,255,0.1); border:none; padding: 5px; color: white; border-radius: 5px; }

        .btn { padding: 10px 20px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; color: white; transition: all 0.2s; }
        .btn-primary { background: linear-gradient(135deg, #7b2cbf, #9d4edd); width: 100%; margin-top: 15px; font-size: 1.1rem; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-small { padding: 5px 10px; font-size: 0.9rem; }

        /* æ’­æ”¾å™¨ */
        .preview-section .track-item { display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; margin-bottom: 10px; }
        .track-color { width: 5px; height: 30px; border-radius: 5px; }
        .track-main .track-color { bg: #00d4ff; }
        .track-name { flex: 1; }
        .track-controls { display: flex; align-items: center; gap: 8px; }
        .volume-slider { width: 80px; }
        
        .mix-controls { display: flex; justify-content: center; gap: 20px; margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .mix-btn { width: 50px; height: 50px; border-radius: 50%; border: none; cursor: pointer; font-size: 1.2rem; color: white; display: flex; align-items: center; justify-content: center; }
        .play-all-btn { background: #00d4ff; }
        .stop-btn { background: #ff6b6b; }

        .full-width { grid-column: 1 / -1; }
        .pitch-canvas { width: 100%; height: 150px; background: rgba(0,0,0,0.2); border-radius: 10px; }
        
        /* å¯¼å‡ºåŒºåŸŸ */
        .export-section .export-actions { display: flex; gap: 15px; justify-content: center; margin-top: 20px; }
        .loading-text { font-size: 0.9rem; color: #00d4ff; text-align: center; margin-top: 5px; display: none; }
        
        /* è½¨é“é¢œè‰²æ ‡å¿— */
        .track-main .track-color { background: #00d4ff; }
        .track-harmony1 .track-color { background: #7b2cbf; }
.track-harmony2 .track-color { background: #ff6b6b; }
        .track-harmony3 .track-color { background: #2ecc71; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸµ äººå£°å’Œå£°ç”Ÿæˆå™¨</h1>
            <p>å½•åˆ¶æˆ–ä¸Šä¼ æ‚¨çš„å“¼å”±ï¼Œä½¿ç”¨å‰ç«¯æŠ€æœ¯è‡ªåŠ¨ç”Ÿæˆå’Œè°çš„å¤šå£°éƒ¨</p>
        </header>
        
        <div class="main-grid">
            <!-- å½•éŸ³åŒºåŸŸ -->
            <div class="card record-section">
                <h2><span class="icon" style="background: linear-gradient(135deg, #ff6b6b, #ee5a5a);">ğŸ¤</span>å½•éŸ³ / ä¸Šä¼ </h2>
                <div class="record-controls">
                    <button id="recordBtn" class="record-btn idle">ğŸ™ï¸</button>
                    <div class="record-status" id="recordStatus">ç‚¹å‡»å¼€å§‹å½•éŸ³</div>
                    <div class="record-time" id="recordTime">00:00</div>
                </div>
                <div class="waveform-container">
                    <canvas id="waveformCanvas" class="waveform-canvas"></canvas>
                </div>
                <div class="pitch-display">
                    <div class="pitch-item">
                        <label>å½“å‰éŸ³é«˜</label>
                        <div class="value" id="currentPitch">--</div>
                    </div>
                    <div class="pitch-item">
                        <label>éŸ³ç¬¦</label>
                        <div class="value" id="currentNote">--</div>
                    </div>
                </div>
                <div class="file-upload" id="fileUpload">
                    <input type="file" id="audioFile" accept="audio/*">
                    <p>ğŸ“ æˆ–ç‚¹å‡»æ­¤å¤„ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶ (MP3/WAV)</p>
                </div>
            </div>

            <!-- å’Œå£°è®¾ç½® -->
            <div class="card harmony-section">
                <h2><span class="icon" style="background: linear-gradient(135deg, #7b2cbf, #9d4edd);">ğŸ¹</span>å’Œå£°è®¾ç½®</h2>
                <div class="harmony-voices">
                    <!-- å£°éƒ¨ 1 -->
                    <div class="voice-control active" id="voice1Control">
                        <div class="voice-header">
                            <label><input type="checkbox" id="voice1Enable" checked> å’Œå£°å£°éƒ¨ 1</label>
                            <span style="color: #7b2cbf;">â—</span>
                        </div>
                        <div class="voice-settings">
                            <select id="voice1Interval">
                                <option value="-5">ä¸‹æ–¹å››åº¦ (-5 ST)</option>
                                <option value="-4">ä¸‹æ–¹å¤§ä¸‰åº¦ (-4 ST)</option>
                                <option value="-3" selected>ä¸‹æ–¹å°ä¸‰åº¦ (-3 ST)</option>
                                <option value="3">ä¸Šæ–¹å°ä¸‰åº¦ (+3 ST)</option>
                                <option value="4">ä¸Šæ–¹å¤§ä¸‰åº¦ (+4 ST)</option>
                            </select>
                            <input type="range" id="voice1Volume" min="0" max="100" value="70" title="éŸ³é‡">
                        </div>
                    </div>
                    <!-- å£°éƒ¨ 2 -->
                    <div class="voice-control active" id="voice2Control">
                        <div class="voice-header">
                            <label><input type="checkbox" id="voice2Enable"> å’Œå£°å£°éƒ¨ 2</label>
                            <span style="color: #ff6b6b;">â—</span>
                        </div>
                        <div class="voice-settings">
                            <select id="voice2Interval">
                                <option value="-7">ä¸‹æ–¹äº”åº¦ (-7 ST)</option>
                                <option value="5">ä¸Šæ–¹å››åº¦ (+5 ST)</option>
                                <option value="7" selected>ä¸Šæ–¹äº”åº¦ (+7 ST)</option>
                            </select>
                            <input type="range" id="voice2Volume" min="0" max="100" value="60" title="éŸ³é‡">
                        </div>
                    </div>
                     <!-- å£°éƒ¨ 3 -->
                     <div class="voice-control active" id="voice3Control">
                        <div class="voice-header">
                            <label><input type="checkbox" id="voice3Enable"> å’Œå£°å£°éƒ¨ 3</label>
                            <span style="color: #2ecc71;">â—</span>
                        </div>
                        <div class="voice-settings">
                            <select id="voice3Interval">
                                <option value="-12">ä¸‹æ–¹å…«åº¦ (-12 ST)</option>
                                <option value="12">ä¸Šæ–¹å…«åº¦ (+12 ST)</option>
                            </select>
                            <input type="range" id="voice3Volume" min="0" max="100" value="50" title="éŸ³é‡">
                        </div>
                    </div>
                </div>
                <div class="generate-section">
                    <button id="generateBtn" class="btn btn-primary" disabled>âœ¨ ç”Ÿæˆå’Œå£°</button>
                    <div id="genStatus" class="loading-text">æ­£åœ¨å¤„ç†éŸ³é¢‘... 0%</div>
                </div>
            </div>

            <!-- éŸ³é«˜åˆ†æå¯è§†åŒ– (Full Width) -->
            <div class="card full-width">
                 <h2><span class="icon" style="background: linear-gradient(135deg, #f39c12, #e67e22);">ğŸ“Š</span>éŸ³é«˜è½¨è¿¹</h2>
                 <canvas id="pitchCanvas" class="pitch-canvas"></canvas>
            </div>

            <!-- é¢„è§ˆä¸å¯¼å‡º -->
            <div class="card full-width preview-section">
                <h2><span class="icon" style="background: linear-gradient(135deg, #00d4ff, #0099cc);">ğŸ§</span>æ’­æ”¾ä¸å¯¼å‡º</h2>
                
                <div class="player-controls">
                    <!-- ä¸»æ—‹å¾‹ -->
                    <div class="track-item track-main">
                        <div class="track-color"></div>
                        <span class="track-name">ä¸»æ—‹å¾‹ (äººå£°)</span>
                        <div class="track-controls">
                            <button class="btn btn-small" onclick="toggleMute('main')" id="btnMuteMain">ğŸ”Š</button>
                            <input type="range" class="volume-slider" id="volMain" oninput="updateMixVolume('main', this.value)" value="100">
                        </div>
                    </div>
                    <!-- å’Œå£°è½¨ 1 -->
                    <div class="track-item track-harmony1" id="track1" style="opacity: 0.5;">
                        <div class="track-color"></div>
                        <span class="track-name">å’Œå£° 1</span>
                        <div class="track-controls">
                            <button class="btn btn-small" onclick="toggleMute('h1')" id="btnMuteH1">ğŸ”Š</button>
                            <input type="range" class="volume-slider" id="volH1" oninput="updateMixVolume('h1', this.value)" value="70">
                        </div>
                    </div>
                    <!-- å’Œå£°è½¨ 2 -->
                    <div class="track-item track-harmony2" id="track2" style="opacity: 0.5;">
                        <div class="track-color"></div>
                        <span class="track-name">å’Œå£° 2</span>
                        <div class="track-controls">
                            <button class="btn btn-small" onclick="toggleMute('h2')" id="btnMuteH2">ğŸ”Š</button>
                            <input type="range" class="volume-slider" id="volH2" oninput="updateMixVolume('h2', this.value)" value="60">
                        </div>
                    </div>
                    <!-- å’Œå£°è½¨ 3 -->
                    <div class="track-item track-harmony3" id="track3" style="opacity: 0.5;">
                        <div class="track-color"></div>
                        <span class="track-name">å’Œå£° 3</span>
                        <div class="track-controls">
                            <button class="btn btn-small" onclick="toggleMute('h3')" id="btnMuteH3">ğŸ”Š</button>
                            <input type="range" class="volume-slider" id="volH3" oninput="updateMixVolume('h3', this.value)" value="50">
                        </div>
                    </div>
                </div>

                <div class="mix-controls">
                    <button class="mix-btn play-all-btn" id="playAllBtn" title="æ’­æ”¾" disabled>â–¶</button>
                    <button class="mix-btn stop-btn" id="stopAllBtn" title="åœæ­¢" disabled>â¹</button>
                    <button class="btn btn-primary" id="downloadBtn" style="width: auto; margin-top: 0;" disabled>ğŸ“¥ å¯¼å‡ºæ··éŸ³ (WAV)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- æ ¸å¿ƒé€»è¾‘è„šæœ¬ -->
    <script>
        // --- 1. å…¨å±€å˜é‡ ---
        let audioCtx;
        let mediaRecorder;
        let audioChunks = [];
        let originalBuffer = null;
        let harmonyBuffers = { h1: null, h2: null, h3: null };
        let activeSources = [];
        let gainNodes = {};
        let isRecording = false;
        let isPlaying = false;
        let startTime = 0;
        let recordingTimerInterval;
        let analyser, dataArray, bufferLength;
        let drawVisual;

        // éŸ³ç¬¦åç§°æ˜ å°„
        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

        // --- 2. åˆå§‹åŒ–ä¸å½•éŸ³ ---
        
        async function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
        }

        const recordBtn = document.getElementById('recordBtn');
        const recordStatus = document.getElementById('recordStatus');
        const recordTimeDisplay = document.getElementById('recordTime');
        const canvas = document.getElementById('waveformCanvas');
        const canvasCtx = canvas.getContext('2d');

        recordBtn.addEventListener('click', async () => {
            await initAudio();

            if (!isRecording) {
                // å¼€å§‹å½•éŸ³
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    // è®¾ç½®å¯è§†åŒ–
                    const source = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048;
                    source.connect(analyser);

                    mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        originalBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                        
                        recordStatus.innerText = "å½•éŸ³å®Œæˆ";
                        document.getElementById('generateBtn').disabled = false;
                        analyzePitch(originalBuffer);
                        visualizeBuffer(); // ç”»å‡ºé™æ€æ³¢å½¢
                        
                        // åœæ­¢éº¦å…‹é£æµ
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.classList.remove('idle');
                    recordBtn.classList.add('recording');
                    recordBtn.innerText = "â¹";
                    recordStatus.innerText = "æ­£åœ¨å½•éŸ³...";
                    
                    startTime = Date.now();
                    recordingTimerInterval = setInterval(updateRecordTimer, 100);
                    visualizeLive(); // å®æ—¶æ³¢å½¢

                } catch (err) {
                    console.error("æ— æ³•è®¿é—®éº¦å…‹é£", err);
                    alert("æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚");
                }
            } else {
                // åœæ­¢å½•éŸ³
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.classList.remove('recording');
                recordBtn.classList.add('idle');
                recordBtn.innerText = "ğŸ™ï¸";
                clearInterval(recordingTimerInterval);
                cancelAnimationFrame(drawVisual);
            }
        });

        function updateRecordTimer() {
            const elapsed = Date.now() - startTime;
            const secs = Math.floor(elapsed / 1000);
            const mins = Math.floor(secs / 60);
            const ss = secs % 60;
            recordTimeDisplay.innerText = `${mins.toString().padStart(2, '0')}:${ss.toString().padStart(2, '0')}`;
        }

        // --- 3. æ–‡ä»¶ä¸Šä¼  ---
        document.querySelector('.file-upload').addEventListener('click', () => {
            document.getElementById('audioFile').click();
        });

        document.getElementById('audioFile').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                await initAudio();
                const file = e.target.files[0];
                recordStatus.innerText = "æ­£åœ¨åŠ è½½æ–‡ä»¶...";
                const arrayBuffer = await file.arrayBuffer();
                originalBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                recordStatus.innerText = `æ–‡ä»¶å·²åŠ è½½: ${file.name}`;
                document.getElementById('generateBtn').disabled = false;
                analyzePitch(originalBuffer);
                visualizeBuffer();
            }
        });

        // --- 4. å¯è§†åŒ–æ³¢å½¢ä¸éŸ³é«˜ ---

        // å®æ—¶å½•éŸ³æ³¢å½¢
        function visualizeLive() {
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            function draw() {
                drawVisual = requestAnimationFrame(draw);
                analyser.getByteTimeDomainData(dataArray);

                canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height); // æ®‹å½±æ•ˆæœ
                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = '#00d4ff';
                canvasCtx.beginPath();

                const sliceWidth = canvas.width * 1.0 / bufferLength;
                let x = 0;

                for(let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height/2;

                    if(i === 0) canvasCtx.moveTo(x, y);
                    else canvasCtx.lineTo(x, y);
                    x += sliceWidth;
                }
                canvasCtx.lineTo(canvas.width, canvas.height/2);
                canvasCtx.stroke();
                
                // ç®€å•çš„å®æ—¶éŸ³é«˜æ£€æµ‹
                detectPitchLive();
            }
            draw();
        }

        // é™æ€æ³¢å½¢ï¼ˆå½•éŸ³/ä¸Šä¼ åï¼‰
        function visualizeBuffer() {
            const rawData = originalBuffer.getChannelData(0); // å–å·¦å£°é“
            const step = Math.ceil(rawData.length / canvas.width);
            const amp = canvas.height / 2;
            
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            canvasCtx.fillStyle = '#00d4ff';
            for(let i = 0; i < canvas.width; i++){
                let min = 1.0;
                let max = -1.0;
                for (let j=0; j<step; j++) {
                    const datum = rawData[i*step + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }
                canvasCtx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
            }
        }

        // ç®€å•çš„è‡ªç›¸å…³ç®—æ³•æ£€æµ‹éŸ³é«˜
        function autoCorrelate(buf, sampleRate) {
            let SIZE = buf.length;
            let rms = 0;
            for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < 0.01) return -1; // å£°éŸ³å¤ªå°

            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++)
                if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            for (let i = 1; i < SIZE / 2; i++)
                if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

            buf = buf.slice(r1, r2);
            SIZE = buf.length;

            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++)
                for (let j = 0; j < SIZE - i; j++)
                    c[i] = c[i] + buf[j] * buf[j + i];

            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
            }
            let T0 = maxpos;
            return sampleRate / T0;
        }

        function detectPitchLive() {
            const buffer = new Float32Array(analyser.fftSize);
            analyser.getFloatTimeDomainData(buffer);
            const pitch = autoCorrelate(buffer, audioCtx.sampleRate);
            
            if (pitch !== -1 && pitch > 50 && pitch < 3000) {
                document.getElementById('currentPitch').innerText = Math.round(pitch) + " Hz";
                let noteNum = 12 * (Math.log(pitch / 440) / Math.log(2)) + 69;
                let note = noteStrings[Math.round(noteNum) % 12];
                document.getElementById('currentNote').innerText = note;
            }
        }

        // --- æ ¸å¿ƒç®—æ³•ï¼šç”Ÿæˆå’Œå£° (ç®€å•çš„é‡é‡‡æ ·+çª—å‡½æ•°å¤„ç†) ---
        // æ³¨æ„ï¼šé«˜è´¨é‡çš„å˜è°ƒï¼ˆä¸å˜é€Ÿï¼‰å¾ˆéš¾åœ¨çº¯å‰ç«¯JSå•çº¿ç¨‹ä¸­å®æ—¶å®Œç¾å®ç°ã€‚
        // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ç¦»çº¿å¤„ç†(OfflineAudioContext)æ¥å®ç°ä¸€ä¸ªç®€åŒ–ç‰ˆçš„ "Granular Pitch Shift" é€»è¾‘ã€‚
        
        async function generateHarmonies() {
            if(!originalBuffer) return;
            const statusDiv = document.getElementById('genStatus');
            statusDiv.style.display = "block";
            document.getElementById('generateBtn').disabled = true;

            const voices = [
                { id: 'h1', enable: 'voice1Enable', interval: 'voice1Interval' },
                { id: 'h2', enable: 'voice2Enable', interval: 'voice2Interval' },
                { id: 'h3', enable: 'voice3Enable', interval: 'voice3Interval' }
            ];

            for (let v of voices) {
                if (document.getElementById(v.enable).checked) {
                    statusDiv.innerText = `æ­£åœ¨ç”Ÿæˆ ${v.id.toUpperCase()}...`;
                    // è·å–éœ€è¦çš„åŠéŸ³åç§»é‡
                    const semitones = parseInt(document.getElementById(v.interval).value);
                    // ç”Ÿæˆå˜è°ƒåçš„Buffer
                    harmonyBuffers[v.id] = await pitchShiftBuffer(originalBuffer, semitones);
                    
                    // æ¿€æ´»UI
                    document.getElementById('track'+v.id.replace('h','')).style.opacity = "1";
                } else {
                    harmonyBuffers[v.id] = null;
                    document.getElementById('track'+v.id.replace('h','')).style.opacity = "0.5";
                }
            }

            statusDiv.innerText = "ç”Ÿæˆå®Œæˆï¼";
            document.getElementById('playAllBtn').disabled = false;
            document.getElementById('stopAllBtn').disabled = false;
            document.getElementById('downloadBtn').disabled = false;
            document.getElementById('generateBtn').disabled = false;
        }

        document.getElementById('generateBtn').addEventListener('click', generateHarmonies);

        // *** æ ¸å¿ƒå˜è°ƒå‡½æ•° ***
        // ç®—æ³•åŸç†ï¼šå°†éŸ³é¢‘åˆ‡æˆå°ç‰‡æ®µ(grains)ï¼Œæ”¹å˜æ’­æ”¾é€Ÿç‡ä»¥æ”¹å˜éŸ³é«˜ï¼Œ
        // ç„¶åé‡å è¿™äº›ç‰‡æ®µä»¥ä¿æŒåŸå§‹æ—¶é•¿ã€‚
        async function pitchShiftBuffer(buffer, semitones) {
            if (semitones === 0) return buffer;

            // è®¡ç®—éŸ³é«˜æ¯”ç‡
            const ratio = Math.pow(2, semitones / 12);
            
            // ä½¿ç”¨ OfflineAudioContext è¿›è¡Œæ¸²æŸ“
            const offlineCtx = new OfflineAudioContext(
                buffer.numberOfChannels,
                buffer.duration * buffer.sampleRate,
                buffer.sampleRate
            );

            // é¢—ç²’åˆæˆå‚æ•°
            const grainSize = 0.05; // 50ms é¢—ç²’å¤§å°
            const overlap = 0.025;  // 25ms é‡å 
            
            const sourceData = buffer.getChannelData(0); // ç®€åŒ–ï¼šåªå¤„ç†å•å£°é“æˆ–å·¦å£°é“ç„¶åå¤åˆ¶
            
            // ä¸ºäº†ç®€åŒ– Demo ä¸”ä¿è¯æ€§èƒ½ï¼Œè¿™é‡Œä½¿ç”¨ä¸€ç§ naive çš„æ–¹æ³•ï¼š
            // åˆ›å»ºå¤šä¸ª AudioBufferSourceNodeï¼Œæ”¹å˜ playbackRateï¼Œä½†é€šè¿‡å»¶è¿Ÿå¯åŠ¨æ¥æ¨¡æ‹Ÿæ—¶é—´ä¼¸ç¼© (Time Stretching) 
            // æˆ–è€…æ˜¯ç®€å•åœ°æ¥å—åªæœ‰éŸ³è°ƒå˜åŒ– (Chipmuk effect)ï¼Ÿ 
            // -> ä¸ºäº†å’Œå£°å’Œè°ï¼Œå¿…é¡»ä¿æŒåŸå§‹æ—¶é•¿ã€‚
            // -> è¿™é‡Œå®ç°ä¸€ä¸ªæç®€çš„ Granular é€»è¾‘ï¼š

            // åˆ›å»ºä¸€ä¸ªæ–°çš„ Buffer
            const outputBuffer = offlineCtx.createBuffer(
                buffer.numberOfChannels,
                buffer.length,
                buffer.sampleRate
            );

            // ç®€å•çš„ OLA (Overlap-Add) å˜è°ƒç®—æ³• - JS å®ç°ç‰ˆ
            // è¿™æ¯” Web Audio API èŠ‚ç‚¹æ›´åº•å±‚
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const inputData = buffer.getChannelData(channel);
                const outputData = outputBuffer.getChannelData(channel);
                
                // é¢—ç²’å¤§å° (samples)
                const grainSizeSamples = Math.round(grainSize * buffer.sampleRate);
                
                // æˆ‘ä»¬åœ¨è¾“å‡ºä¸Šç§»åŠ¨ï¼Œå¡«å……å¯¹åº”çš„å†…å®¹
                for (let i = 0; i < inputData.length; i += grainSizeSamples / 2) {
                    // åœ¨åŸéŸ³é¢‘ä¸­çš„ä½ç½®ï¼Œä»¥ä¿æŒèŠ‚å¥åŒæ­¥
                    const inputOffset = Math.floor(i); 
                    
                    if (inputOffset + grainSizeSamples >= inputData.length) break;

                    // å†™å…¥é¢—ç²’
                    for (let j = 0; j < grainSizeSamples; j++) {
                        // åœ¨é¢—ç²’å†…éƒ¨ï¼Œæˆ‘ä»¬é€šè¿‡æ¯”ç‡(ratio)è¯»å–æ•°æ®æ¥å®ç°å˜è°ƒ
                        // å¦‚æœ ratio > 1 (å‡è°ƒ)ï¼Œæˆ‘ä»¬åœ¨æ›´çŸ­çš„æ•°æ®ä¸Šé‡‡æ ·
                        const targetIdx = Math.floor(inputOffset + j * ratio);
                        
                        // ç®€å•çš„æ±‰å®çª— (Hanning Window) é¿å…çˆ†éŸ³
                        const window = 0.5 * (1 - Math.cos(2 * Math.PI * j / grainSizeSamples));
                        if (targetIdx < inputData.length && (i+j) < outputData.length) {
                             outputData[i + j] += inputData[targetIdx] * window;
                        }
                    }
                }
            }

            return outputBuffer;
        }
// --- 5. æ’­æ”¾æ§åˆ¶ ---

        function updateMixVolume(track, val) {
            const gain = val / 100;
            if (gainNodes[track]) {
                gainNodes[track].gain.value = gain;
            }
            // å­˜å‚¨éŸ³é‡åå¥½ï¼Œä¾›ä¸‹æ¬¡æ’­æ”¾ä½¿ç”¨
            document.getElementById(track === 'main' ? 'volMain' : track === 'h1' ? 'volH1' : track === 'h2' ? 'volH2' : 'volH3').dataset.gain = gain;
        }

        function toggleMute(track) {
            const btn = document.getElementById(track === 'main' ? 'btnMuteMain' : track === 'h1' ? 'btnMuteH1' : track === 'h2' ? 'btnMuteH2' : 'btnMuteH3');
            let slider = document.getElementById(track === 'main' ? 'volMain' : track === 'h1' ? 'volH1' : track === 'h2' ? 'volH2' : 'volH3');
            
            if (gainNodes[track]) {
                if (gainNodes[track].gain.value > 0) {
                    // Mute
                    slider.dataset.lastVal = gainNodes[track].gain.value;
                    gainNodes[track].gain.value = 0;
                    slider.value = 0;
                    btn.innerText = "ğŸ”‡";
                } else {
                    // Unmute
                    const lastVal = slider.dataset.lastVal || 1;
                    gainNodes[track].gain.value = lastVal;
                    slider.value = lastVal * 100;
                    btn.innerText = "ğŸ”Š";
                }
            }
        }

        document.getElementById('playAllBtn').addEventListener('click', () => {
            if (isPlaying) stopAll();
            startPlayback();
        });

        document.getElementById('stopAllBtn').addEventListener('click', stopAll);

        function startPlayback() {
            if (!originalBuffer) return;
            activeSources = [];
            gainNodes = {};

            // è¾…åŠ©å‡½æ•°ï¼šæ’­æ”¾å•ä¸ª Buffer
            function playTrack(buffer, id, volInputId) {
                if (!buffer) return;
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                const gainNode = audioCtx.createGain();
                
                // è¯»å–å½“å‰æ»‘å—éŸ³é‡
                const vol = document.getElementById(volInputId).value / 100;
                gainNode.gain.value = vol;

                source.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                source.start(0);
                
                activeSources.push(source);
                gainNodes[id] = gainNode;
                
                // ç›‘å¬ç»“æŸ
source.onended = () => {
                   // ç®€å•å¤„ç†ï¼šå½“ä¸»è½¨é“ç»“æŸæ—¶é‡ç½®çŠ¶æ€
                   if(id === 'main') {
                       isPlaying = false;
                       document.getElementById('playAllBtn').innerHTML = "â–¶";
                   }
                };
            }

            playTrack(originalBuffer, 'main', 'volMain');
            if(harmonyBuffers.h1) playTrack(harmonyBuffers.h1, 'h1', 'volH1');
            if(harmonyBuffers.h2) playTrack(harmonyBuffers.h2, 'h2', 'volH2');
            if(harmonyBuffers.h3) playTrack(harmonyBuffers.h3, 'h3', 'volH3');

            isPlaying = true;
            document.getElementById('playAllBtn').innerHTML = "â¸"; // æ­¤æ—¶ä»…ä½œä¸ºæŒ‡ç¤º
        }

        function stopAll() {
            activeSources.forEach(s => {
                try { s.stop(); } catch(e){}
            });
            activeSources = [];
            isPlaying = false;
            document.getElementById('playAllBtn').innerHTML = "â–¶";
        }

        // --- 6. å¯¼å‡ºåŠŸèƒ½ ---
        
        document.getElementById('downloadBtn').addEventListener('click', async () => {
             if (!originalBuffer) return;
             const btn = document.getElementById('downloadBtn');
             btn.innerText = "â³ æ­£åœ¨åˆæˆ...";
             btn.disabled = true;

             // ä½¿ç”¨ OfflineAudioContext è¿›è¡Œæ··éŸ³å¯¼å‡º
             const duration = originalBuffer.duration;
             const offlineCtx = new OfflineAudioContext(2, duration * 44100, 44100);

             function addOfflineTrack(buffer, volId) {
if(!buffer) return;
                 const src = offlineCtx.createBufferSource();
                 src.buffer = buffer;
                 const gn = offlineCtx.createGain();
                 gn.gain.value = document.getElementById(volId).value / 100;
                 src.connect(gn);
                 gn.connect(offlineCtx.destination);
                 src.start(0);
             }

             addOfflineTrack(originalBuffer, 'volMain');
             if(harmonyBuffers.h1) addOfflineTrack(harmonyBuffers.h1, 'volH1');
             if(harmonyBuffers.h2) addOfflineTrack(harmonyBuffers.h2, 'volH2');
             if(harmonyBuffers.h3) addOfflineTrack(harmonyBuffers.h3, 'volH3');

             const renderedBuffer = await offlineCtx.startRendering();
// å°† AudioBuffer è½¬ä¸º WAV æ–‡ä»¶
             const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
             const url = URL.createObjectURL(wavBlob);
             const link = document.createElement('a');
             link.href = url;
             link.download = 'ai_harmony_mix.wav';
             link.click();
             
             btn.innerText = "ğŸ“¥ å¯¼å‡ºæ··éŸ³ (WAV)";
             btn.disabled = false;
        });

        // ç®€å•çš„ WAV ç¼–ç å™¨
        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample,
                offset = 0,
                pos = 0;

            // write WAVE header
            setUint32(0x46464952);                         // "RIFF"
            setUint32(length - 8);                         // file length - 8
            setUint32(0x45564157);                         // "WAVE"

            setUint32(0x20746d66);                         // "fmt " chunk
            setUint32(16);                                 // length = 16
            setUint16(1);                                  // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2);                      // block-align
            setUint16(16);                                 // 16-bit (hardcoded in this demo)

            setUint32(0x61746164);                         // "data" - chunk
            setUint32(length - pos - 4);                   // chunk length

            // write interleaved data
            for(i = 0; i < abuffer.numberOfChannels; i++)
                channels.push(abuffer.getChannelData(i));

            while(pos < len) {
                for(i = 0; i < numOfChan; i++) {
                    // interleave channels
                    sample = Math.max(-1, Math.min(1, channels[i][pos])); // clamp
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int
                    view.setInt16(44 + offset, sample, true);
                    offset += 2;
                }
                pos++;
            }

            return new Blob([buffer], {type: "audio/wav"});
function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
        }

        // --- 7. éŸ³é«˜è½¨è¿¹åˆ†æ (å ä½ç¬¦) ---
        // çœŸæ­£çš„å…¨æ›²éŸ³é«˜æ£€æµ‹è¿‡äºå¤æ‚ï¼Œè¿™é‡Œç”Ÿæˆä¸€ä¸ªåŸºäºæŒ¯å¹…çš„ä¼ªæ³¢å½¢å›¾æ¥å¡«å……UI
        function analyzePitch(buffer) {
            const canvasP = document.getElementById('pitchCanvas');
            const ctx = canvasP.getContext('2d');
            const data = buffer.getChannelData(0);
            const step = Math.ceil(data.length / 400); // ä¸‹é‡‡æ ·
            
            canvasP.width = canvasP.offsetWidth;
            canvasP.height = canvasP.offsetHeight;
            ctx.clearRect(0,0, canvasP.width, canvasP.height);

            ctx.beginPath();
            ctx.moveTo(0, canvasP.height/2);
            ctx.strokeStyle = "#f39c12";
            ctx.lineWidth = 2;

            for(let i=0; i < 400; i++) {
                let val = data[i*step];
                // æ¨¡æ‹ŸéŸ³é«˜ï¼šæŒ¯å¹…è¶Šå¤§è¿™é‡Œç”»å¾—è¶Šé«˜ï¼ŒåŠ ä¸€ç‚¹éšæœº
                let y = canvasP.height/2 - (Math.abs(val) * 100) - (Math.random()*10); 
                y = Math.max(10, Math.min(canvasP.height-10, y));
                ctx.lineTo(i * (canvasP.width/400), y);
            }
            ctx.stroke();
            
            // ä¸‹æ–¹åŠ ä¸€ç‚¹æ–‡å­—
            ctx.fillStyle = "#888";
            ctx.font = "12px Arial";
            ctx.fillText(`æ—¶é•¿: ${buffer.duration.toFixed(2)}s | é‡‡æ ·ç‡: ${buffer.sampleRate}Hz`, 10, canvasP.height - 10);
        }

    </script>
</body>
</html>
