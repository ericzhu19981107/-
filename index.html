<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ¶ å’Œå£°ç»ƒä¹ å™¨ v3.1 (ä¿®å¤ç‰ˆ)</title>
<script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
<style>
  body { font-family: 'Segoe UI', sans-serif; text-align: center; padding: 20px; background: #f0f2f5; color: #333; }
  .container { max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
  h2 { color: #5a67d8; margin-bottom: 20px; }
  .controls { margin: 20px 0; display: flex; flex-direction: column; gap: 15px; align-items: center; }
  select, button { padding: 12px 24px; font-size: 16px; border-radius: 8px; border: 1px solid #cbd5e0; cursor: pointer; transition: 0.2s; }
  button { background: #5a67d8; color: white; border: none; font-weight: bold; width: 80%; }
  button:hover { background: #4c51bf; }
  button:disabled { background: #cbd5e0; cursor: not-allowed; }
  button#stop { background: #e53e3e; }
  .checkbox-wrapper { display: flex; align-items: center; gap: 10px; font-size: 16px; margin-top: 10px; }
  input[type="checkbox"] { transform: scale(1.5); cursor: pointer; }
  audio { margin-top: 25px; width: 100%; outline: none; }
  .status { margin-top: 15px; font-size: 14px; color: #718096; min-height: 20px; font-weight: bold; }
  .error { color: #e53e3e; }
</style>
</head>
<body>

<div class="container">
  <h2>ğŸ¶ å’Œå£°ç»ƒä¹ å™¨ <small style="font-size:0.6em; color:#999">v3.1</small></h2>

  <div class="controls">
    <select id="mode">
      <option value="4">å¤§ä¸‰åº¦ (Major 3rd)</option>
      <option value="3">å°ä¸‰åº¦ (Minor 3rd)</option>
      <option value="-4">ä½å¤§ä¸‰åº¦ (Lower Maj 3rd)</option>
      <option value="5">çº¯äº”åº¦ (Perfect 5th)</option>
      <option value="smart">ğŸ² éšæœºå¤§å°ä¸‰åº¦</option>
    </select>

    <div class="checkbox-wrapper">
      <input type="checkbox" id="soloToggle">
      <label for="soloToggle">åªå¬å’Œå£° (Solo Harmony)</label>
    </div>

    <button id="record">ğŸ¤ å¼€å§‹å½•éŸ³</button>
    <button id="stop" disabled>â¹ åœæ­¢å¹¶ç”Ÿæˆ</button>
  </div>

  <div class="status" id="statusText">æ­£åœ¨æ£€æŸ¥ç¯å¢ƒ...</div>
  <audio id="player" controls></audio>
</div>

<script>
// æ£€æŸ¥ Tone.js æ˜¯å¦åŠ è½½æˆåŠŸ
window.onload = function() {
  const statusText = document.getElementById("statusText");
  if (typeof Tone === 'undefined') {
    statusText.innerText = "âŒ é”™è¯¯ï¼šTone.js åº“åŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚";
    statusText.classList.add("error");
    document.getElementById("record").disabled = true;
    alert("Tone.js éŸ³é¢‘åº“æœªèƒ½åŠ è½½ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜ã€‚è¯·å°è¯•è¿æ¥ VPN æˆ–æ›´æ¢ç½‘ç»œç¯å¢ƒã€‚");
  } else {
    statusText.innerText = "âœ… å‡†å¤‡å°±ç»ª (ç‚¹å‡»å½•éŸ³)";
  }
};

let recorder, chunks = [];
const recordBtn = document.getElementById("record");
const stopBtn = document.getElementById("stop");
const player = document.getElementById("player");
const mode = document.getElementById("mode");
const soloToggle = document.getElementById("soloToggle");
const statusText = document.getElementById("statusText");

recordBtn.onclick = async () => {
  try {
    // 1. å…ˆå°è¯•å¯åŠ¨ Tone.js ä¸Šä¸‹æ–‡ (è§£å†³éƒ¨åˆ†æµè§ˆå™¨é™åˆ¶)
    if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
      await Tone.start();
    }

    // 2. è¯·æ±‚éº¦å…‹é£æƒé™
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    
    // 3. å¼€å§‹å½•éŸ³
    recorder = new MediaRecorder(stream);
    chunks = [];
    recorder.ondataavailable = e => chunks.push(e.data);
    
    recorder.onstop = processAudio; // ç»‘å®šå¤„ç†å‡½æ•°

    recorder.start();
    recordBtn.disabled = true;
    stopBtn.disabled = false;
    statusText.innerText = "ğŸ”´ æ­£åœ¨å½•éŸ³... (è¯´å®Œè¯·æŒ‰åœæ­¢)";
    statusText.classList.remove("error");
    player.src = "";

  } catch (err) {
    console.error(err);
    if (err.name === 'NotAllowedError') {
      statusText.innerText = "âŒ æ— æ³•å½•éŸ³ï¼šè¯·å…è®¸éº¦å…‹é£æƒé™ï¼";
    } else if (err.name === 'ReferenceError') {
      statusText.innerText = "âŒ æ— æ³•å½•éŸ³ï¼šæ ¸å¿ƒåº“ä¸¢å¤±ï¼Œè¯·åˆ·æ–°é¡µé¢ã€‚";
    } else {
      statusText.innerText = "âŒ é”™è¯¯ï¼š" + err.message;
    }
    statusText.classList.add("error");
    alert("å½•éŸ³å¯åŠ¨å¤±è´¥ï¼š" + err.message + "\nå¦‚æœæ˜¯åœ¨æœ¬åœ°ç›´æ¥æ‰“å¼€ html æ–‡ä»¶ï¼Œè¯·å°è¯•æ”¹ç”¨ Chrome æˆ–æ­å»ºæœ¬åœ°æœåŠ¡å™¨ã€‚");
  }
};

stopBtn.onclick = () => {
  if (recorder && recorder.state === "recording") {
    recorder.stop();
    // åœæ­¢éº¦å…‹é£å ç”¨
    recorder.stream.getTracks().forEach(track => track.stop());
  }
  recordBtn.disabled = false;
  stopBtn.disabled = true;
};

// éŸ³é¢‘å¤„ç†æ ¸å¿ƒé€»è¾‘
async function processAudio() {
  statusText.innerText = "â³ æ­£åœ¨è®¡ç®—å’Œå£°åŒæ­¥ï¼Œè¯·ç¨å€™...";
  
  try {
    const blob = new Blob(chunks, { type: 'audio/webm' });
    const arrayBuffer = await blob.arrayBuffer();
    
    // è§£ç éŸ³é¢‘
    const context = new AudioContext();
    const originalBuffer = await context.decodeAudioData(arrayBuffer);

    // è·å–è®¾ç½®
    let semitones = mode.value === "smart"
      ? (Math.random() > 0.5 ? 3 : 4)
      : Number(mode.value);
    const isSolo = soloToggle.checked;

    // ä½¿ç”¨ Tone.Offline æ¸²æŸ“
    const renderDuration = originalBuffer.duration + 0.5;
    
    const renderedBuffer = await Tone.Offline(async () => {
      const sourcePlayer = new Tone.Player(originalBuffer);
      
      const pitchShifter = new Tone.PitchShift({
        pitch: semitones,
        windowSize: 0.1,
        delayTime: 0,
        feedback: 0
      });

      if (isSolo) {
        sourcePlayer.connect(pitchShifter);
        pitchShifter.toDestination();
      } else {
        sourcePlayer.toDestination();
        sourcePlayer.connect(pitchShifter);
        pitchShifter.toDestination();
        sourcePlayer.volume.value = -2; 
      }

      sourcePlayer.start(0);
    }, renderDuration);

    const wavBlob = bufferToWave(renderedBuffer);
    player.src = URL.createObjectURL(wavBlob);
    statusText.innerText = `âœ… å®Œæˆï¼éŸ³ç¨‹ï¼š${semitones} åŠéŸ³`;

  } catch (e) {
    statusText.innerText = "âŒ å¤„ç†å¤±è´¥ï¼š" + e.message;
    statusText.classList.add("error");
    console.error(e);
  }
}

// è¾…åŠ©å‡½æ•°ï¼šå¯¼å‡º WAV
function bufferToWave(abuffer) {
  const numOfChan = abuffer.numberOfChannels;
  const length = abuffer.length * numOfChan * 2 + 44;
  const buffer = new ArrayBuffer(length);
  const view = new DataView(buffer);
  const channels = [];
  let i, sample;
  let offset = 0;
  let pos = 0;

  const setUint16 = (data) => { view.setUint16(pos, data, true); pos += 2; }
  const setUint32 = (data) => { view.setUint32(pos, data, true); pos += 4; }

  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8); 
  setUint32(0x45564157); // "WAVE"
  setUint32(0x20746d66); // "fmt "
  setUint32(16); 
  setUint16(1); 
  setUint16(numOfChan);
  setUint32(abuffer.sampleRate);
  setUint32(abuffer.sampleRate * 2 * numOfChan); 
  setUint16(numOfChan * 2); 
  setUint16(16); 
  setUint32(0x61746164); // "data"
  setUint32(length - pos - 4); 

  for (i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

  while (pos < length) {
    for (i = 0; i < numOfChan; i++) {
      sample = Math.max(-1, Math.min(1, channels[i][offset])); 
      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; 
      view.setInt16(pos, sample, true); 
      pos += 2;
    }
    offset++; 
  }
  return new Blob([buffer], { type: "audio/wav" });
}
</script>

</body>
</html>
