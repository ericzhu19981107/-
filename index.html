<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ¶ æ™ºèƒ½å’Œå£°ç»ƒä¹ å™¨ v2.0</title>
<style>
  body { font-family: sans-serif; text-align: center; padding: 20px; background: #f4f4f9; color: #333; }
  h2 { color: #5a67d8; }
  select, button { padding: 10px 20px; font-size: 16px; margin: 10px; border-radius: 5px; border: 1px solid #ccc; cursor: pointer; }
  button { background: #5a67d8; color: white; border: none; }
  button:disabled { background: #ccc; cursor: not-allowed; }
  button#stop { background: #e53e3e; }
  audio { margin-top: 20px; width: 80%; }
  .status { margin-top: 10px; font-size: 14px; color: #666; }
</style>
</head>
<body>

<h2>ğŸ¶ æ™ºèƒ½å’Œå£°ç»ƒä¹ å™¨</h2>
<p>æ³¨æ„ï¼šåŸç”Ÿå˜é€Ÿå˜è°ƒä¼šå¯¼è‡´æ—¶é•¿æ”¹å˜ï¼ˆé«˜éŸ³å˜å¿«ï¼Œä½éŸ³å˜æ…¢ï¼‰</p>

<select id="mode">
  <option value="4">å¤§ä¸‰åº¦ (Major 3rd)</option>
  <option value="3">å°ä¸‰åº¦ (Minor 3rd)</option>
  <option value="-4">ä½å¤§ä¸‰åº¦ (Lower Maj 3rd)</option>
  <option value="5">çº¯äº”åº¦ (Perfect 5th)</option>
  <option value="smart">ğŸ² éšæœº/æ™ºèƒ½æ¨¡å¼</option>
</select>

<br>

<button id="record">ğŸ¤ å¼€å§‹å½•éŸ³</button>
<button id="stop" disabled>â¹ åœæ­¢å¹¶ç”Ÿæˆå’Œå£°</button>

<div class="status" id="statusText">å‡†å¤‡å°±ç»ª</div>
<br>
<audio id="player" controls></audio>

<script>
let recorder, chunks = [];
const recordBtn = document.getElementById("record");
const stopBtn = document.getElementById("stop");
const player = document.getElementById("player");
const mode = document.getElementById("mode");
const statusText = document.getElementById("statusText");

// 1. å¼€å§‹å½•éŸ³
recordBtn.onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    recorder = new MediaRecorder(stream);
    chunks = [];
    
    recorder.ondataavailable = e => chunks.push(e.data);
    
    recorder.onstop = async () => {
      statusText.innerText = "æ­£åœ¨å¤„ç†éŸ³é¢‘...";
      const blob = new Blob(chunks, { type: 'audio/webm' }); // æ˜ç¡®æŒ‡å®šæ ¼å¼
      const buf = await blob.arrayBuffer();
      const ctx = new AudioContext();
      const originalAudio = await ctx.decodeAudioData(buf);

      // è®¡ç®—åŠéŸ³æ•°
      let semitones = mode.value === "smart"
        ? (Math.random() > 0.5 ? 3 : 4) // éšæœºå¤§å°ä¸‰åº¦
        : Number(mode.value);

      // ç”Ÿæˆå˜è°ƒåçš„éŸ³é¢‘ Buffer
      const shiftedBuffer = await pitchShift(originalAudio, semitones);
      
      // æ··åˆ åŸå£° + å˜è°ƒå£°
      const mixedBuffer = mixBuffers(ctx, originalAudio, shiftedBuffer);

      // è½¬æ¢ä¸º WAV å¹¶æ’­æ”¾
      const wav = bufferToWave(mixedBuffer);
      player.src = URL.createObjectURL(wav);
      statusText.innerText = `ç”Ÿæˆå®Œæ¯•ï¼å½“å‰å’Œå£°ï¼š${semitones} åŠéŸ³`;
    };

    recorder.start();
    recordBtn.disabled = true;
    stopBtn.disabled = false;
    statusText.innerText = "ğŸ”´ æ­£åœ¨å½•éŸ³...";
  } catch (err) {
    alert("æ— æ³•è·å–éº¦å…‹é£æƒé™");
    console.error(err);
  }
};

// 2. åœæ­¢å½•éŸ³
stopBtn.onclick = () => {
  recorder.stop();
  recordBtn.disabled = false;
  stopBtn.disabled = true;
};

// 3. æ ¸å¿ƒå˜è°ƒå‡½æ•° (åŸºäº playbackRate)
async function pitchShift(buffer, semitones) {
  const rate = Math.pow(2, semitones / 12);
  // å˜è°ƒåçš„æ—¶é•¿ = åŸæ—¶é•¿ / é€Ÿç‡
  const newLength = Math.ceil(buffer.length / rate); 
  
  const off = new OfflineAudioContext(
    buffer.numberOfChannels,
    newLength,
    buffer.sampleRate
  );
  
  const src = off.createBufferSource();
  src.buffer = buffer;
  src.playbackRate.value = rate;
  src.connect(off.destination);
  src.start();
  
  return await off.startRendering();
}

// 4. æ–°å¢ï¼šæ··åˆä¸¤ä¸ª Buffer (åŸå£° + å’Œå£°)
function mixBuffers(ctx, bufferA, bufferB) {
  // å–æœ€é•¿çš„é‚£ä¸ªæ—¶é•¿
  const len = Math.max(bufferA.length, bufferB.length);
  const channels = bufferA.numberOfChannels;
  const out = ctx.createBuffer(channels, len, bufferA.sampleRate);

  for (let c = 0; c < channels; c++) {
    const dataA = bufferA.getChannelData(c);
    const dataB = bufferB.getChannelData(c);
    const dataOut = out.getChannelData(c);

    for (let i = 0; i < len; i++) {
      // ç®€å•çš„ç›¸åŠ æ··åˆï¼Œå¹¶ä¹˜ä»¥ 0.6 é˜²æ­¢ç ´éŸ³
      const valA = (i < dataA.length) ? dataA[i] : 0;
      const valB = (i < dataB.length) ? dataB[i] : 0;
      dataOut[i] = (valA + valB) * 0.6; 
    }
  }
  return out;
}

// 5. Buffer è½¬ WAV (ä¿æŒåŸæ ·)
function bufferToWave(abuffer) {
  const num = abuffer.numberOfChannels;
  const len = abuffer.length * num * 2 + 44;
  const buf = new ArrayBuffer(len);
  const view = new DataView(buf);
  let pos = 0;
  const write = s => { for (let i=0;i<s.length;i++) view.setUint8(pos++, s.charCodeAt(i)); };

  write('RIFF'); view.setUint32(pos, len-8, true); pos+=4;
  write('WAVEfmt '); view.setUint32(pos,16,true); pos+=4;
  view.setUint16(pos,1,true); pos+=2;
  view.setUint16(pos,num,true); pos+=2;
  view.setUint32(pos,abuffer.sampleRate,true); pos+=4;
  view.setUint32(pos,abuffer.sampleRate*2*num,true); pos+=4;
  view.setUint16(pos,num*2,true); pos+=2;
  view.setUint16(pos,16,true); pos+=2;
  write('data'); view.setUint32(pos,len-pos-4,true); pos+=4;

  for (let i=0;i<abuffer.length;i++) {
    for (let c=0;c<num;c++) {
      // å¢åŠ æº¢å‡ºä¿æŠ¤
      let s = Math.max(-1, Math.min(1, abuffer.getChannelData(c)[i]));
      view.setInt16(pos, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      pos+=2;
    }
  }
  return new Blob([view], {type:'audio/wav'});
}
</script>

</body>
</html>
