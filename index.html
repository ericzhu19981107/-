<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI çº¯å£° - æ™ºèƒ½äººå£°å’Œå£°ç”Ÿæˆå™¨</title>
    <style>
        :root {
            --primary: #00ff88;
            --secondary: #00ccff;
            --bg: #1a1a1a;
            --panel: #2d2d2d;
            --text: #ffffff;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background: var(--panel);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* ç¤ºæ³¢å™¨ */
        canvas {
            width: 100%;
            height: 120px;
            background: #000;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #444;
        }

        /* æ§åˆ¶åŒº */
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 30px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-record { background: #ff4444; color: white; }
        .btn-record.recording { animation: pulse 1.5s infinite; background: #cc0000; }
        .btn-stop { background: #444; color: white; }
        .btn-play { background: var(--primary); color: #000; }
        .btn-export { background: var(--secondary); color: #000; }
        
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); }
        }

        /* æ··éŸ³å° */
        .mixer {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: 12px;
        }

        .track {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .track-label {
            width: 80px;
            font-size: 14px;
            color: #aaa;
        }

        .track-controls {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #444;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--secondary);
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 4px;
        }

        .status {
            text-align: center;
            margin-top: 10px;
            color: #888;
            font-size: 14px;
            height: 20px;
        }
    </style>
</head>
<body>

    <h1>AI çº¯å£° Harmony Gen</h1>

    <div class="container">
        <canvas id="visualizer"></canvas>

        <div class="status" id="statusText">å‡†å¤‡å°±ç»ª - è¯·ç‚¹å‡»å½•éŸ³</div>

        <div class="controls">
            <button id="btnRecord" class="btn-record">ğŸ¤ å¼€å§‹å½•éŸ³</button>
            <button id="btnStop" class="btn-stop" disabled>â¹ åœæ­¢</button>
            <button id="btnPlay" class="btn-play" disabled>â–¶ï¸ ç”Ÿæˆå¹¶æ’­æ”¾</button>
            <button id="btnExport" class="btn-export" disabled>â¬‡ï¸ å¯¼å‡ºéŸ³é¢‘</button>
        </div>

        <div class="mixer">
            <div class="track">
                <div class="track-label">ä¸»æ—‹å¾‹</div>
                <div class="track-controls">
                    <input type="range" id="volMain" min="0" max="1.5" step="0.1" value="1.0">
                </div>
            </div>

            <div class="track">
                <div class="track-label">å’Œå£° I</div>
                <div class="track-controls">
                    <select id="intervalH1">
                        <option value="3">å¤§ä¸‰åº¦ (é«˜)</option>
                        <option value="4">çº¯å››åº¦ (é«˜)</option>
                        <option value="5">çº¯äº”åº¦ (é«˜)</option>
                        <option value="-5">çº¯äº”åº¦ (ä½)</option>
                    </select>
                    <input type="range" id="volH1" min="0" max="1.2" step="0.1" value="0.6">
                </div>
            </div>

            <div class="track">
                <div class="track-label">å’Œå£° II</div>
                <div class="track-controls">
                    <select id="intervalH2">
                        <option value="-4">çº¯å››åº¦ (ä½)</option>
                        <option value="-3">å°ä¸‰åº¦ (ä½)</option>
                        <option value="7">å…«åº¦ (é«˜)</option>
                        <option value="3">å¤§ä¸‰åº¦ (é«˜)</option>
                    </select>
                    <input type="range" id="volH2" min="0" max="1.2" step="0.1" value="0.4">
                </div>
            </div>

            <div class="track">
                <div class="track-label">ç©ºé—´æ··å“</div>
                <div class="track-controls">
                    <input type="range" id="volReverb" min="0" max="1" step="0.1" value="0.3">
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- æ ¸å¿ƒéŸ³é¢‘å˜é‡ ---
        let audioCtx;
        let mediaRecorder;
        let audioChunks = [];
        let originalBuffer = null;
        let isRecording = false;
        let isPlaying = false;
        let activeSources = [];

        // DOM å…ƒç´ 
        const btnRecord = document.getElementById('btnRecord');
        const btnStop = document.getElementById('btnStop');
        const btnPlay = document.getElementById('btnPlay');
        const btnExport = document.getElementById('btnExport');
        const statusText = document.getElementById('statusText');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');

        // åˆå§‹åŒ– AudioContext (ç”¨æˆ·äº¤äº’åè§¦å‘)
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- å½•éŸ³åŠŸèƒ½ ---
        btnRecord.onclick = async () => {
            initAudio();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                const arrayBuffer = await audioBlob.arrayBuffer();
                originalBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                statusText.innerText = "å½•éŸ³å®Œæˆï¼è¯·é…ç½®å’Œå£°å¹¶æ’­æ”¾";
                btnPlay.disabled = false;
                
                // åœæ­¢éº¦å…‹é£å ç”¨
                stream.getTracks().forEach(track => track.stop());
            };

            mediaRecorder.start();
            isRecording = true;
            btnRecord.classList.add('recording');
            btnRecord.disabled = true;
            btnStop.disabled = false;
            btnPlay.disabled = true;
            btnExport.disabled = true;
            statusText.innerText = "æ­£åœ¨å½•éŸ³... è¯·å“¼å”±ä¸€æ®µæ—‹å¾‹";
            visualize(stream);
        };

        btnStop.onclick = () => {
            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                btnRecord.classList.remove('recording');
                btnRecord.disabled = false;
                btnStop.disabled = true;
            } else {
                stopPlayback();
            }
        };

        // --- æ ¸å¿ƒç®—æ³•ï¼šå˜è°ƒè€Œä¸å˜é€Ÿ (Granular Pitch Shift) ---
        // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„é¢—ç²’åˆæˆç®—æ³•ï¼Œç”¨äºåœ¨æµè§ˆå™¨ä¸­ç¦»çº¿å¤„ç† Buffer
        function createPitchShiftedBuffer(buffer, semitones) {
            if (semitones === 0) return buffer;

            const channels = buffer.numberOfChannels;
            const rate = 1.059463094359 ** semitones; // 2^(1/12)
            const outputBuffer = audioCtx.createBuffer(channels, buffer.length, buffer.sampleRate);
            
            // é¢—ç²’å¤§å° (ç§’)
            const grainSize = 0.05; 
            const grainSamples = Math.floor(grainSize * buffer.sampleRate);
            const overlap = 0.5; // 50% é‡å 
            const stride = Math.floor(grainSamples * (1 - overlap));

            for (let ch = 0; ch < channels; ch++) {
                const inputData = buffer.getChannelData(ch);
                const outputData = outputBuffer.getChannelData(ch);
                
                // æˆ‘ä»¬éœ€è¦å¡«å……æ•´ä¸ªè¾“å‡ºç¼“å†²åŒº
                // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šä¿æŒè¾“å‡ºçš„æ—¶é—´è½´ä¸å˜ (i)ï¼Œä½†åœ¨è¾“å…¥ä¸­å¯»æ‰¾å¯¹åº”çš„ä½ç½®
                // ç”±äºç®€å•çš„é‡é‡‡æ ·ä¼šæ”¹å˜é€Ÿåº¦ï¼Œæˆ‘ä»¬åˆ‡ç¢éŸ³é¢‘ï¼Œå¯¹æ¯ä¸€å°å—è¿›è¡Œé‡é‡‡æ ·(å˜è°ƒ)ï¼Œ
                // ç„¶åæŠŠå®ƒä»¬æ‹¼å›åˆ°åŸå§‹çš„æ—¶é—´ä½ç½®ä¸Šã€‚
                
                for (let i = 0; i < outputData.length; i += stride) {
                    // å½“å‰é¢—ç²’åœ¨åŸéŸ³é¢‘ä¸­çš„å¤§è‡´ä½ç½®
                    const inputOffset = i; 
                    
                    // å¡«å……ä¸€ä¸ªé¢—ç²’
                    for (let j = 0; j < grainSamples; j++) {
                        if (i + j >= outputData.length) break;

                        // åœ¨é¢—ç²’å†…éƒ¨ï¼Œæˆ‘ä»¬æŒ‰ç…§å˜è°ƒåçš„é€Ÿç‡è¯»å–æ•°æ®
                        // rate > 1 (å‡è°ƒ): è¯»å–é€Ÿåº¦å˜å¿«
                        const inputIndex = inputOffset + Math.floor(j * rate);
                        
                        if (inputIndex < inputData.length) {
                            // ç®€å•çš„æ±‰å®çª— (Hanning Window) é¿å…çˆ†éŸ³
                            const window = 0.5 * (1 - Math.cos((2 * Math.PI * j) / (grainSamples - 1)));
                            // ç´¯åŠ æ··åˆ (å› ä¸ºæœ‰é‡å )
                            outputData[i + j] += inputData[inputIndex] * window;
                        }
                    }
                }
            }
            return outputBuffer;
        }

        // --- ç”Ÿæˆæ··å“è„‰å†² ---
        function createReverbBuffer() {
            const length = audioCtx.sampleRate * 2.0; // 2ç§’æ··å“
            const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const data = impulse.getChannelData(ch);
                for (let i = 0; i < length; i++) {
                    // æŒ‡æ•°è¡°å‡çš„ç™½å™ªå£°
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                }
            }
            return impulse;
        }

        // --- æ’­æ”¾é€»è¾‘ ---
        btnPlay.onclick = async () => {
            if (isPlaying) {
                stopPlayback();
                return;
            }

            statusText.innerText = "æ­£åœ¨è®¡ç®—å’Œå£°...";
            // ç¨å¾®å»¶è¿Ÿè®©UIåˆ·æ–°
            setTimeout(async () => {
                startPlayback();
            }, 50);
        };

        async function startPlayback(isExport = false) {
            if (!originalBuffer) return;

            // 1. è·å–è®¾ç½®
            const shift1 = parseInt(document.getElementById('intervalH1').value);
            const shift2 = parseInt(document.getElementById('intervalH2').value);
            const volMainVal = parseFloat(document.getElementById('volMain').value);
            const volH1Val = parseFloat(document.getElementById('volH1').value);
            const volH2Val = parseFloat(document.getElementById('volH2').value);
            const volReverbVal = parseFloat(document.getElementById('volReverb').value);

            // 2. å¤„ç†éŸ³é¢‘ (è®¡ç®—å˜è°ƒ)
            const h1Buffer = createPitchShiftedBuffer(originalBuffer, shift1);
            const h2Buffer = createPitchShiftedBuffer(originalBuffer, shift2);

            // 3. æ„å»ºéŸ³é¢‘å›¾è°±
            // ç›®æ ‡èŠ‚ç‚¹ï¼šå¦‚æœæ˜¯å¯¼å‡ºï¼Œè¿æ¥åˆ° MediaStreamDestinationï¼Œå¦åˆ™è¿æ¥åˆ° speakers
            let destination;
            let exportStreamNode;
            
            if (isExport) {
                exportStreamNode = audioCtx.createMediaStreamDestination();
                destination = exportStreamNode;
            } else {
                destination = audioCtx.destination;
            }

            // ä¸»å‹ç¼©å™¨ (é˜²æ­¢å‰Šæ³¢)
            const compressor = audioCtx.createDynamicsCompressor();
            compressor.threshold.value = -20;
            compressor.ratio.value = 10;
            compressor.connect(destination);

            // æ··å“æ€»çº¿
            const reverbNode = audioCtx.createConvolver();
            reverbNode.buffer = createReverbBuffer();
            const reverbGain = audioCtx.createGain();
            reverbGain.gain.value = volReverbVal;
            reverbNode.connect(reverbGain);
            reverbGain.connect(compressor);

            // åˆ›å»ºå£°æºå‡½æ•°
            function createSource(buffer, gainValue, panValue) {
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                
                const gain = audioCtx.createGain();
                gain.gain.value = gainValue;

                const panner = audioCtx.createStereoPanner();
                panner.pan.value = panValue;

                // è·¯ç”±ï¼šæº -> å¢ç›Š -> å£°ç›¸ -> (ç›´é€šå‹ç¼©å™¨ + å‘é€æ··å“)
                source.connect(gain);
                gain.connect(panner);
                panner.connect(compressor); // å¹²å£°
                panner.connect(reverbNode); // æ¹¿å£°

                return source;
            }

            // å®ä¾‹åŒ–å£°é“
            const srcMain = createSource(originalBuffer, volMainVal, 0);       // ä¸»å”±ï¼šå±…ä¸­
            const srcH1 = createSource(h1Buffer, volH1Val, -0.5);              // å’Œå£°1ï¼šå·¦å
            const srcH2 = createSource(h2Buffer, volH2Val, 0.5);               // å’Œå£°2ï¼šå³å

            activeSources = [srcMain, srcH1, srcH2];
            activeSources.forEach(s => s.start(0));

            // å¤„ç†çŠ¶æ€
            if (!isExport) {
                isPlaying = true;
                btnPlay.innerHTML = "â¸ åœæ­¢æ’­æ”¾";
                btnRecord.disabled = true;
                btnExport.disabled = false;
                statusText.innerText = "æ’­æ”¾ä¸­...";
                
                // è‡ªåŠ¨åœæ­¢å¤„ç†
                srcMain.onended = () => {
                    if(isPlaying) stopPlayback();
                };
            } else {
                // å¯¼å‡ºæ¨¡å¼ï¼šè¿”å›æµèŠ‚ç‚¹å’Œæ—¶é•¿
                return { stream: exportStreamNode.stream, duration: originalBuffer.duration };
            }
        }

        function stopPlayback() {
            activeSources.forEach(s => {
                try { s.stop(); } catch(e){}
            });
            activeSources = [];
            isPlaying = false;
            btnPlay.innerHTML = "â–¶ï¸ ç”Ÿæˆå¹¶æ’­æ”¾";
            btnRecord.disabled = false;
            statusText.innerText = "å·²åœæ­¢";
        }

        // --- å¯¼å‡ºåŠŸèƒ½ ---
        btnExport.onclick = async () => {
            statusText.innerText = "æ­£åœ¨æ¸²æŸ“å¯¼å‡ºæ–‡ä»¶...";
            btnExport.disabled = true;

            const { stream, duration } = await startPlayback(true);
            const recorder = new MediaRecorder(stream);
            const chunks = [];

            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `harmony_mix_${new Date().getTime()}.wav`;
                a.click();
                statusText.innerText = "å¯¼å‡ºå®Œæˆï¼";
                btnExport.disabled = false;
            };

            recorder.start();
            // å½•åˆ¶å¯¹åº”æ—¶é•¿ååœæ­¢
            setTimeout(() => {
                recorder.stop();
                stopPlayback(); // åœæ­¢å†…éƒ¨æº
            }, duration * 1000 + 500); // å¤šå½•0.5ç§’å°¾éŸ³
        };

        // --- å¯è§†åŒ– ---
        function visualize(stream) {
            const source = audioCtx.createMediaStreamSource(stream);
            const analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            source.connect(analyser);
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                if (!isRecording) return;
                requestAnimationFrame(draw);
                analyser.getByteTimeDomainData(dataArray);

                canvasCtx.fillStyle = '#1a1a1a';
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = '#00ff88';
                canvasCtx.beginPath();

                const sliceWidth = canvas.width * 1.0 / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    if (i === 0) canvasCtx.moveTo(x, y);
                    else canvasCtx.lineTo(x, y);
                    x += sliceWidth;
                }
                canvasCtx.lineTo(canvas.width, canvas.height / 2);
                canvasCtx.stroke();
            }
            draw();
        }

        // çª—å£è°ƒæ•´
        window.onresize = () => {
            canvas.width = canvas.parentElement.offsetWidth;
        };
        window.onresize();

    </script>
</body>
</html>
