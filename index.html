<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ¶ æ™ºèƒ½å³å…´å’Œå£° v4.2</title>
<script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
<style>
  body { font-family: 'Segoe UI', sans-serif; text-align: center; padding: 20px; background: #f4f7f6; }
  .container { max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.05); }
  h2 { color: #4c51bf; }
  button { width: 100%; padding: 15px; margin: 10px 0; border-radius: 12px; border: none; font-weight: bold; cursor: pointer; font-size: 16px; }
  #record { background: #4c51bf; color: white; }
  #stop { background: #f56565; color: white; }
  #stop:disabled { background: #edf2f7; color: #a0aec0; }
  .status { margin: 15px 0; font-weight: bold; color: #5a67d8; }
  audio { width: 100%; margin-top: 20px; }
  .options { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px; }
</style>
</head>
<body>

<div class="container">
  <h2>ğŸ¶ å³å…´å’Œå£°ç»ƒä¹ å™¨</h2>
  <div class="status" id="statusText">ç­‰å¾…åˆå§‹åŒ–...</div>
  
  <div class="options">
    <input type="checkbox" id="soloToggle">
    <label for="soloToggle">åªå¬å³å…´å’Œå£°</label>
  </div>

  <button id="record">ğŸ¤ å¼€å§‹å½•éŸ³</button>
  <button id="stop" disabled>â¹ åœæ­¢å¹¶åˆæˆ</button>
  
  <audio id="player" controls></audio>
</div>

<script>
let recorder, chunks = [];
const statusText = document.getElementById("statusText");
const recordBtn = document.getElementById("record");
const stopBtn = document.getElementById("stop");
const player = document.getElementById("player");
const soloToggle = document.getElementById("soloToggle");

window.onload = () => {
  if (typeof Tone === 'undefined') statusText.innerText = "âŒ åº“åŠ è½½å¤±è´¥";
  else statusText.innerText = "âœ… å‡†å¤‡å°±ç»ª";
};

recordBtn.onclick = async () => {
  try {
    await Tone.start();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    recorder = new MediaRecorder(stream);
    chunks = [];
    recorder.ondataavailable = e => chunks.push(e.data);
    recorder.onstop = processAudio;
    recorder.start();
    
    recordBtn.disabled = true;
    stopBtn.disabled = false;
    statusText.innerText = "ğŸ”´ å½•éŸ³ä¸­ï¼Œè¯·å”±æ­Œ...";
  } catch (err) {
    statusText.innerText = "âŒ æ— æ³•è®¿é—®éº¦å…‹é£";
  }
};

stopBtn.onclick = () => {
  recorder.stop();
  recorder.stream.getTracks().forEach(t => t.stop());
  recordBtn.disabled = false;
  stopBtn.disabled = true;
};

async function processAudio() {
  statusText.innerText = "â³ æ­£åœ¨æ¿€å‘å³å…´ä¼´å”±...";
  try {
    const blob = new Blob(chunks);
    const arrayBuffer = await blob.arrayBuffer();
    const audioBuffer = await Tone.context.decodeAudioData(arrayBuffer);

    const isSolo = soloToggle.checked;
    const renderDuration = audioBuffer.duration + 1.0;

    const renderedBuffer = await Tone.Offline(async () => {
      const source = new Tone.Player(audioBuffer);
      
      // 1. æ ¸å¿ƒå˜è°ƒå™¨
      const shifter = new Tone.PitchShift({ windowSize: 0.1 });
      
      // 2. æ•ˆæœé“¾ï¼ˆå»æ‰ .start() ä»¥ä¿®å¤æŠ¥é”™ï¼‰
      const vibrato = new Tone.Vibrato(4, 0.1); 
      const chorus = new Tone.Chorus(2, 2, 0.2); 
      const delay = new Tone.Delay(0.03); // 30ms å»¶è¿Ÿï¼Œå¢åŠ ç‹¬ç«‹æ„Ÿ

      // 3. å£°åƒå®šä½ (Stereo Panning)
      const dryPan = new Tone.Panner(-0.4).toDestination(); // åŸå£°é å·¦
      const wetPan = new Tone.Panner(0.5).toDestination();  // å’Œå£°é å³

      // 4. å³å…´é€»è¾‘ï¼šæ¯éš”ä¸€æ®µæ—¶é—´éšæœºå˜è°ƒ
      for(let t = 0; t < audioBuffer.duration; t += 0.6) {
        Tone.Transport.schedule(() => {
          // åœ¨ 0(åŸéŸ³), 3(å°ä¸‰), 4(å¤§ä¸‰), 7(äº”åº¦) ä¹‹é—´è·³åŠ¨
          shifter.pitch = [0, 3, 4, 7, 5][Math.floor(Math.random() * 5)];
        }, t);
      }

      if (isSolo) {
        source.chain(shifter, vibrato, chorus, wetPan);
      } else {
        source.connect(dryPan); // åŸå£°
        source.chain(shifter, vibrato, delay, chorus, wetPan); // å’Œå£°
        source.volume.value = -1;
      }

      source.start(0);
      Tone.Transport.start();
    }, renderDuration);

    player.src = URL.createObjectURL(bufferToWave(renderedBuffer));
    statusText.innerText = "âœ¨ å³å…´ä¼´å”±å·²ç”Ÿæˆï¼";
  } catch (e) {
    statusText.innerText = "âŒ å¤±è´¥: " + e.message;
  }
}

function bufferToWave(abuffer) {
  let numOfChan = abuffer.numberOfChannels,
    length = abuffer.length * numOfChan * 2 + 44,
    buffer = new ArrayBuffer(length),
    view = new DataView(buffer),
    channels = [], i, sample, offset = 0, pos = 0;
  const setUint16 = (d) => { view.setUint16(pos, d, true); pos += 2; };
  const setUint32 = (d) => { view.setUint32(pos, d, true); pos += 4; };
  setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157);
  setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
  setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
  setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4);
  for (i = 0; i < numOfChan; i++) channels.push(abuffer.getChannelData(i));
  while (pos < length) {
    for (i = 0; i < numOfChan; i++) {
      sample = Math.max(-1, Math.min(1, channels[i][offset]));
      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
      view.setInt16(pos, sample, true); pos += 2;
    }
    offset++;
  }
  return new Blob([buffer], { type: "audio/wav" });
}
</script>
</body>
</html>
